define(["require","exports","module","lib/pos"],function(t){function r(t,r,n){this.name=t,this.board=null,this.camp=r,this.pos=n}var n=t("lib/pos");return r.prototype={_calcPos:function(t){return new n(this.pos.x+t[0],this.pos.y+t[1])},_isEnemy:function(t){var r=this.board._belong(t);return"none"!=r&&r!=this.camp},_getEnemy:function(){return"red"==this.camp?"black":"red"},equals:function(t){return this==t?!0:this.name==t.name&&this.camp==t.camp&&this.board==t.board&&this.pos.equals(t.pos)},isInArray:function(t){var r=this;return t.filter(function(t){return r.equals(t)}).length>0},isCur:function(){return this.board.curCamp==this.camp},canMove:function(){for(var t,r=[],n=this.calcVectors(),i=0,e=n.length;e>i;i++)t=this._calcPos(n[i]),this.board._isOverBoard(t)||this.isRestrict(t,n[i])||this.board._belong(t)==this.camp||r.push(t);return r},canKill:function(){for(var t=this.canMove(),r=[],n=0,i=t.length;i>n;n++)this._isEnemy(t[n])&&r.push(t[n]);return r},canBeKilled:function(){for(var t=this.board._getPieceArr(this._getEnemy()),r=0,n=t.length;n>r;r++)if(this.pos.isInArray(t[r].canKill()))return!0;return!1},moveTo:function(t){return this.pos.equals(t)?!1:t.isInArray(this.canMove())||t.isInArray(this.canKill())?this.board.execute(this.pos,t):!1},calcVectors:function(){throw new Error("must be overried")},isRestrict:function(){throw new Error("must be overried")}},r});
//# sourceMappingURL=piece.js.map